Ecco un report completo che analizza i problemi di consumo di banda della tua applicazione e fornisce un piano d'azione dettagliato per implementarne le soluzioni, inclusa una migrazione sicura dei dati.

-----

### Report: Ottimizzazione del Consumo di Banda e Refactoring del Database

**Oggetto:** Analisi e piano d'azione per la riduzione drastica del consumo di banda dell'applicazione.
**Data:** 24 ottobre 2025

### 1\. Riepilogo Esecutivo

L'attuale architettura dell'applicazione soffre di un consumo di banda eccessivo a causa di due problemi principali:

1.  **Aggiornamenti ad Alta Frequenza:** L'editor di testo (Tiptap) invia l'**intero documento** al database ad **ogni singola pressione di un tasto**.
2.  **Caricamento Dati Eccessivo:** La query per popolare la sidebar (`getSidebar`) scarica l'**intero contenuto** di **tutte le pagine** dell'utente, anche se deve mostrare solo i titoli.

Questo report delinea un piano in due parti per risolvere questi problemi, con un conseguente risparmio di banda stimato del **90-99%** per gli aggiornamenti e del **95-98%** per il caricamento iniziale.

  * **Soluzione 1 (Debouncing):** Introdurremo un ritardo (debounce) per inviare gli aggiornamenti dell'editor solo quando l'utente smette di digitare.
  * **Soluzione 2 (Normalizzazione):** Separeremo i metadati (es. `titolo`) dal contenuto (`content`) nel database, caricando solo ciò che è strettamente necessario.

Verrà fornita una guida passo-passo per migrare i dati esistenti senza interruzioni del servizio.

-----

### 2\. Diagnosi Dettagliata del Problema

#### Problema 1: Aggiornamenti ad Alta Frequenza (Editor)

Analizzando `components/Editor.tsx`, si nota che l'hook `useEditor` è configurato con un listener `onUpdate`:

```typescript
// in components/Editor.tsx
useEditor({
    // ... estensioni
    content: page.content, 
    onUpdate: ({ editor }) => {
      onContentChange(editor.getJSON()); // <-- PROBLEMA
      // ...
    },
    // ...
});
```

Questo significa che ad ogni modifica (ogni tasto premuto, ogni formattazione), l'intera struttura JSON del documento viene inviata alla funzione `onContentChange` e, presumibilmente, al backend. Se un documento pesa 50KB, scrivere 10 caratteri genera 500KB di traffico in uscita.

#### Problema 2: Caricamento Dati Eccessivo (Sidebar)

Il file `convex/schema.ts` definisce la tabella `pages` in questo modo:

```typescript
// in convex/schema.ts
pages: defineTable({
    title: v.string(),
    userId: v.string(),
    icon: v.optional(v.string()),
    content: v.optional(v.string()), // <-- PROBLEMA
    parentId: v.optional(v.id("pages")),
    isArchived: v.boolean(),
  }).index("byUser", ["userId"]),
```

Il campo `content`, che contiene il JSON pesante dell'editor, si trova *all'interno* dello stesso documento del `title`.

La query `getSidebar` in `convex/pages.ts` recupera tutti i documenti delle pagine per l'utente:

```typescript
// in convex/pages.ts
export const getSidebar = query({
  // ...
  handler: async (ctx, args) => {
    // ...
    const pages = await ctx.db
      .query("pages") // <-- Legge l'intero documento
      .withIndex("byUser", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("isArchived"), false))
      .order("desc")
      .collect(); // <-- Scarica TUTTO, incluso il 'content'

    return pages;
  },
});
```

Questo costringe il frontend a scaricare megabyte di dati di contenuto che non verranno mai utilizzati, solo per visualizzare un elenco di titoli nella sidebar.

-----

### 3\. Piano d'Azione Dettagliato

Implementeremo le soluzioni in modo incrementale e sicuro, partendo dalla migrazione del database.

#### FASE A: Implementare il Debouncing (Soluzione 1)

Questa è la soluzione più rapida da implementare e avrà un impatto immediato.

Nel tuo file principale (es. `App.tsx`), dove gestisci lo stato e passi la funzione `onContentChange` all'Editor, dovrai modificarla.

1.  **Installa `lodash`:**

    ```bash
    npm install lodash
    npm install --save-dev @types/lodash
    ```

2.  **Modifica il gestore `onContentChange` (Esempio in `App.tsx`):**
    Usa `useMemo` e `debounce` per creare una versione "ritardata" della tua funzione di aggiornamento.

    ```tsx
    // In App.tsx (o dove gestisci la logica principale)
    import React, { useMemo } from 'react';
    import { useMutation } from 'convex/react';
    import { api } from './convex/_generated/api';
    import { Id } from './convex/_generated/dataModel';
    import { debounce } from 'lodash';

    // ... (Il tuo componente App)

    // Ottieni la tua mutazione 'update' da Convex
    const updatePage = useMutation(api.pages.update); // Assumendo che usi api.pages.update

    // 1. CREA LA FUNZIONE DEBOUNCED
    // Usiamo useMemo per evitare di ricreare la funzione ad ogni render
    const debouncedUpdateContent = useMemo(() => {
        // Questa funzione verrà eseguita 1 secondo (1000ms) dopo l'ULTIMA
        // volta che è stata chiamata.
        return debounce((pageId: Id<'pages'>, content: any) => {
            
            // !! NOTA: Questo funzionerà ANCHE MEGLIO dopo la FASE C,
            // quando 'update' accetterà solo 'content'.
            updatePage({ 
                id: pageId, 
                content: JSON.stringify(content) // Invia l'aggiornamento
            });
            
        }, 1000); // 1 secondo di attesa

    }, [updatePage]); // Dipende solo dalla mutazione

    // ...

    // 2. QUESTA È LA FUNZIONE CHE PASSI ALL'EDITOR
    const handleContentChange = (content: any) => {
        if (activePage) {
            // Chiama la funzione 'debounced' invece di quella diretta
            debouncedUpdateContent(activePage._id, content);
        }
    };

    // ... (Nel tuo JSX)
    <Editor
      // ...tutte le altre props
      onContentChange={handleContentChange} 
    />
    ```

#### FASE B: Migrazione del Database (Soluzione 2)

Eseguiremo una migrazione sicura in 3 passaggi, senza interrompere il servizio.

**Step B1: Preparare lo Schema (Additivo)**

Modifica `convex/schema.ts` per **aggiungere** la nuova tabella, ma **non rimuovere ancora** il vecchio campo `content`.

```typescript
// in convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  pages: defineTable({
    title: v.string(),
    userId: v.string(),
    icon: v.optional(v.string()),
    content: v.optional(v.string()), // <-- NON RIMUOVERLO ANCORA!
    parentId: v.optional(v.id("pages")),
    isArchived: v.boolean(),
  }).index("byUser", ["userId"]),
  
  // NUOVA TABELLA PER IL CONTENUTO PESANTE
  pageContent: defineTable({
    pageId: v.id("pages"),
    content: v.optional(v.string()), // Il JSON di Tiptap va qui
  }).index("byPageId", ["pageId"]) // Indice per trovarlo velocemente
});
```

Salva questo file e riavvia `npx convex dev`. Il tuo database è ora pronto per la migrazione.

**Step B2: Creare la Funzione di Migrazione**

Crea un nuovo file `convex/migrate.ts`. Questa è una mutazione interna che eseguirai una sola volta.

```typescript
// in convex/migrate.ts
import { internalMutation } from "./_generated/server";

export const migrateData = internalMutation({
  handler: async (ctx) => {
    // 1. Prendi tutte le pagine esistenti (con il vecchio campo 'content')
    const pages = await ctx.db.query("pages").fullTableScan().collect();

    let migratedCount = 0;
    let skippedCount = 0;
    console.log(`[Migrazione] Trovate ${pages.length} pagine da controllare...`);

    for (const page of pages) {
      // 2. Controlla se la pagina ha del contenuto
      if (page.content && page.content.trim() !== "" && page.content.trim() !== "{}") {
        
        // 3. Controlla se abbiamo GIÀ migrato questa pagina (per sicurezza)
        const existing = await ctx.db
          .query("pageContent")
          .withIndex("byPageId", (q) => q.eq("pageId", page._id))
          .unique();

        if (existing) {
          skippedCount++;
        } else {
          // 4. Copia il contenuto nella nuova tabella 'pageContent'
          await ctx.db.insert("pageContent", {
            pageId: page._id,
            content: page.content,
          });
          migratedCount++;
        }
      } else {
        // Pagina senza contenuto, salta
        skippedCount++;
      }
    }

    const result = `[Migrazione] Completata. ${migratedCount} pagine migrate, ${skippedCount} pagine saltate (vuote o già migrate).`;
    console.log(result);
    return result;
  },
});
```

**Step B3: Eseguire la Migrazione**

1.  Assicurati che `npx convex dev` sia in esecuzione.
2.  Apri la **Dashboard di Convex** del tuo progetto.
3.  Vai alla scheda **"Functions"** nel menu a sinistra.
4.  Trova la funzione `migrate:migrateData` e cliccala.
5.  Nel pannello a destra, clicca il pulsante **"Run"** (lascia gli argomenti come `{}`).
6.  Controlla i **Logs** in basso. Vedrai il messaggio: `[Migrazione] Completata...`.

I tuoi dati sono ora duplicati in sicurezza. L'app funziona ancora come prima.

#### FASE C: Aggiornare il Codice Backend (API)

Ora modifichiamo le funzioni Convex in `convex/pages.ts` per usare la nuova struttura.

**Sostituisci l'intero contenuto di `convex/pages.ts` con questo:**

```typescript
// in convex/pages.ts
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Doc, Id } from "./_generated/dataModel";

// 1. 'getSidebar' ora è LEGGERA
// Legge solo dalla tabella 'pages', che non ha più 'content' (dopo la FASE E)
export const getSidebar = query({
  args: {
    parentPage: v.optional(v.id("pages")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }
    const userId = identity.subject;

    const pages = await ctx.db
      .query("pages") // Questo ora legge solo i metadati (titolo, icona, parentId)
      .withIndex("byUser", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("isArchived"), false))
      .order("desc")
      .collect();

    return pages;
  },
});

// 2. NUOVA query per prendere il contenuto SOLO della pagina attiva
export const getContent = query({
  args: { pageId: v.id("pages") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }
    // Cerca il documento di contenuto specifico
    const contentDoc = await ctx.db
      .query("pageContent")
      .withIndex("byPageId", (q) => q.eq("pageId", args.pageId))
      .unique();
      
    // Potrebbe non esistere se la pagina è stata appena creata
    return contentDoc?.content || ""; // Restituisce la stringa JSON o una stringa vuota
  },
});


// 3. 'create' ora crea DUE documenti
export const create = mutation({
  args: {
    title: v.string(),
    parentPage: v.optional(v.id("pages")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }
    const userId = identity.subject;

    // A. Crea la pagina (metadati)
    const pageId = await ctx.db.insert("pages", {
      title: args.title,
      userId,
      icon: "",
      parentId: args.parentPage,
      isArchived: false,
      // 'content' non è più qui
    });

    // B. Crea il documento di contenuto (vuoto)
    await ctx.db.insert("pageContent", {
      pageId: pageId,
      content: "", // Inizia vuoto
    });

    return pageId; // Restituisce l'ID della nuova pagina
  },
});

// 4. 'update' ora gestisce metadati e contenuto separatamente
export const update = mutation({
    args: {
        id: v.id("pages"), // L'ID è sempre quello della 'pagina'
        title: v.optional(v.string()),
        content: v.optional(v.string()),
        icon: v.optional(v.string()),
    },
    handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) throw new Error("Unauthenticated");

        const userId = identity.subject;
        const { id, content, ...metadata } = args; // Separa 'content' dal resto

        // A. Controlla i permessi sulla pagina principale
        const existingPage = await ctx.db.get(id);
        if (!existingPage) throw new Error("Not found");
        if (existingPage.userId !== userId) throw new Error("Unauthorized");

        // B. Aggiorna i metadati (title, icon) se presenti
        if (Object.keys(metadata).length > 0) {
            await ctx.db.patch(id, metadata);
        }

        // C. Aggiorna il contenuto (content) se presente
        if (content !== undefined) {
            // Trova il documento di contenuto associato
            const contentDoc = await ctx.db
              .query("pageContent")
              .withIndex("byPageId", q => q.eq("pageId", id))
              .unique();
              
            if (contentDoc) {
                // Aggiorna se esiste
                await ctx.db.patch(contentDoc._id, { content });
            } else {
                // Crealo se non esiste (per sicurezza)
                await ctx.db.insert("pageContent", { pageId: id, content });
            }
        }
        
        // Restituisci la pagina aggiornata (solo metadati)
        return await ctx.db.get(id);
    },
});


// 5. 'archive' (eliminazione) rimane quasi invariata
// (Potresti voler eliminare anche le voci 'pageContent' in futuro,
// ma per ora questo funziona)
export const archive = mutation({
  args: { id: v.id("pages") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const userId = identity.subject;
    const existingPage = await ctx.db.get(args.id);
    if (!existingPage) throw new Error("Not found");
    if (existingPage.userId !== userId) throw new Error("Unauthorized");
    
    // Archivia ricorsivamente le pagine figlie
    const recursiveArchive = async (pageId: Id<"pages">) => {
        const children = await ctx.db
            .query("pages")
            .withIndex("byUser", q => q.eq("userId", userId))
            .filter(q => q.eq(q.field("parentId"), pageId))
            .collect();

        for (const child of children) {
            await ctx.db.patch(child._id, { isArchived: true });
            await recursiveArchive(child._id);
        }
    }

    const page = await ctx.db.patch(args.id, {
      isArchived: true,
    });
    
    recursiveArchive(args.id);

    return page;
  }
});
```

#### FASE D: Aggiornare il Codice Frontend (Client)

Ora, nel tuo `App.tsx`, devi modificare il modo in cui carichi i dati.

```tsx
// In App.tsx (concettuale)
import { useQuery } from 'convex/react';
import { api } from './convex/_generated/api';

// ...

function App() {
    const [activePageId, setActivePageId] = useState<Id<'pages'> | null>(null);

    // 1. QUESTA QUERY ORA È LEGGERA E VELOCE
    // Carica solo i metadati per la sidebar e la navigazione
    const pages = useQuery(api.pages.getSidebar) || [];

    // 2. NUOVA QUERY: Carica il contenuto SOLO per la pagina attiva
    const activePageContent = useQuery(
        api.pages.getContent,
        activePageId ? { pageId: activePageId } : "skip" // "skip" previene l'esecuzione se l'ID è nullo
    );

    // 3. Trova i metadati della pagina attiva dalla lista 'pages'
    const activePage = pages.find(p => p._id === activePageId);

    // ...

    // 4. PASSA I DATI CORRETTI ALL'EDITOR
    return (
        <main>
            <Sidebar
                pages={pages} // Passa solo i metadati
                activePageId={activePageId}
                onSelectPage={setActivePageId}
                // ...
            />
            
            {activePage && (
                <Editor
                    key={activePage._id} // Importante per forzare il re-render
                    page={activePage} // Passa i metadati (titolo, icona)
                    
                    // PASSA IL CONTENUTO DALLA NUOVA QUERY
                    // (Usa 'activePageContent' o un JSON vuoto se sta caricando)
                    initialContent={activePageContent ? JSON.parse(activePageContent) : undefined}
                    
                    onTitleChange={handleTitleChange} // (Questa userà la mutazione 'update')
                    onContentChange={handleContentChange} // (Questa userà la mutazione 'update' con debounce)
                    // ...
                />
            )}
        </main>
    );
}
```

**Nota:** Dovrai modificare il tuo `<Editor>` per accettare `initialContent` e caricarlo (es. con `editor.commands.setContent(initialContent)` in un `useEffect`) invece di prenderlo da `page.content`.

#### FASE E: Pulizia Finale (Opzionale ma Raccomandata)

Dopo aver testato e confermato che la tua app legge e scrive correttamente usando la nuova struttura:

1.  **Modifica `convex/schema.ts`:**

      * **Rimuovi** la riga `content: v.optional(v.string()),` dalla tabella `pages`.

2.  **Elimina** il file `convex/migrate.ts`. Non è più necessario.

Riavvia `npx convex dev`. Il tuo database è ora pulito e ottimizzato.

-----

### 4\. Miglioramenti Attesi

Implementando queste modifiche, i risultati saranno immediati:

  * **Caricamento Iniziale (Sidebar):** Il tempo di caricamento e il consumo di banda per la visualizzazione della sidebar saranno ridotti del **95-98%**, poiché verranno scaricati solo i metadati (pochi KB) invece di megabyte di contenuti.
  * **Aggiornamenti dell'Editor:** Il traffico generato durante la digitazione sarà ridotto del **90-99%**, poiché gli aggiornamenti verranno inviati solo 1 secondo dopo che l'utente ha smesso di digitare, invece che a ogni tasto.